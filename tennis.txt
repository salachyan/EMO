-- pico tennis
-- by paranoid cactus

function _init()
    settings,next_game_state,logo_timer,musicplaying = {1,1,2,3},3,60,false
    sfx(7)
end

function _update60()
    game_state = next_game_state

    if game_state == 0 then
        update_game()
        update_menu(main_menu,0)
    elseif game_state == 1 then
        update_game_settings()
    elseif game_state == 2 then
        update_game()
    elseif game_state == 3 then
        logo_timer -= 1
        if logo_timer <= 0 then
            next_game_state = 0
            init_world()
            init_player_pool()
            init_main_menu()
        end
    end
end

function _draw()
    if (game_state ~= next_game_state) return
    cls(1)
    if game_state == 0 then
        cls(13)
        draw_game()
        sspr(0,64,105,40,12,1)
        draw_menu(main_menu,4,91)
        sspr(0,110,30,12,96,114)
    elseif game_state == 1 then
        draw_game_settings()
    elseif game_state == 2 then
        draw_game()
    elseif game_state == 3 then
        cls(0)
        sspr(72,104,30,22,47,50)
    end
end
-->8
-- main menu
function init_main_menu()
    player_count,total_sets_list = 2,{1,3,5}
    new_game(true)
    main_menu = {
        selected_index = 1,scroll_offset=1,visible_items=4,
        {"play",0,init_game_settings},
        {"type",1,settings,1,{"singles","doubles"}},
        {"set score",1,settings,2,{3,6}},
        {"sets",1,settings,3,total_sets_list},
        {"cpu",1,settings,4,{"stupid","easy","normal","hard","pro"}}
    }
    menu_current,next_game_state = main_menu,0
    if not musicplaying then
        music(0)
    end
end

function update_menu(menu,controller)
    local selected_option = menu[menu.selected_index]
    local val3,val4 = selected_option[3],selected_option[4]
    if selected_option[2] == 0 then
        if btnp(4,controller) then
            val3(val4)
        end
    else
        if btnp(0,controller) then
            val3[val4] = val3[val4] == 1 and #selected_option[5] or val3[val4]-1
        end
        if btnp(1,controller) then
            val3[val4] = val3[val4]%#selected_option[5]+1
        end
    end
    if btnp(2,controller) then
        menu.selected_index = menu.selected_index == 1 and #menu or menu.selected_index-1
    end
    if btnp(3,controller) then
        menu.selected_index = menu.selected_index%#menu+1
    end
    if menu.selected_index < menu.scroll_offset then
        menu.scroll_offset = menu.selected_index
    elseif menu.selected_index > menu.scroll_offset+menu.visible_items then
        menu.scroll_offset = menu.selected_index-menu.visible_items
    end
end

function draw_menu(menu,x,y)
    local top = y
    rectfill(x-2,y-2,x+50,y+menu.visible_items*7+6,1)
    for i=menu.scroll_offset,min(menu.scroll_offset+menu.visible_items,#menu) do
        local menu_item,txt_col = menu[i],6
        if menu.selected_index == i then
            rectfill(x-1,y-1,x+49,y+5,12)
            txt_col = 7
        end
        print(menu_item[1],x,y,txt_col)
        if menu_item[6] then
            menu_item[6](x+#menu_item[1]*4,y,menu_item[3][menu_item[4]],menu_item[5])
        elseif menu_item[2] == 1 then
            local str = ""..menu_item[5][menu_item[3][menu_item[4]]]
            print(str,x+50-#str*4,y,7)
        end
        y += 7
    end
    if menu.scroll_offset > 1 then
        sspr(67,107,5,4,x+45,top-4)
    end
    if menu.scroll_offset+menu.visible_items < #menu then
        sspr(67,104,5,4,x+45,y-2)
    end
end

-->8
-- game settings
function read_color_range(x,y,count,set_size)
    local color_range = {}
    for i=1,count do
        local set = {}
        for j=1,set_size do
            add(set,sget(x,y))
            x += 1
        end
        add(color_range,set)
    end
    return color_range
end

function init_player_pool()
    color_sets,player_count,inactive_controllers,inactive_player_settings,active_player_settings,player_settings = { read_color_range(0,8,7,2),read_color_range(0,9,2,1),read_color_range(0,10,6,2),read_color_range(0,11,7,1) },2,{0,1,2,3,4,5,6,7},{},{},{}

    for i=1,4 do
        local p = add(inactive_player_settings,add(player_settings, { 
            index = i,
            controller = nil,
            selected_option = 1,
            colors = {
                flr(rnd(#color_sets[1]))+1,
                flr(rnd(#color_sets[2]))+1,
                flr(rnd(#color_sets[3]))+1,
                flr(rnd(#color_sets[4]))+1
                }
            }))
        p.player,p.menu = new_player(0,0,0.5,p.colors,nil,(i-1)%2+1),{
            selected_index = 1,scroll_offset=1,visible_items=3,
            -- label,type,value_table,value_key,display_values,[special_draw_func]
            {"ready",0,ready_player,p},
            {"suit ",1,p.colors,1,color_sets[1],draw_color_range},
            {"skin ",1,p.colors,2,color_sets[2],draw_color_range},
            {"hair ",1,p.colors,3,color_sets[3],draw_color_range},
            {"eyes ",1,p.colors,4,color_sets[4],draw_color_range},
            {"back out",0,remove_player,p}
        }
    end
end

function init_game_settings()
    player_count,inactive_controllers,inactive_player_settings,active_player_settings = settings[1]*2,{0,1,2,3,4,5,6,7},{},{}
   
    for k,v in pairs(player_settings) do
        v.player,v.menu.selected_index = new_player(0,0,0.5,v.colors,nil,(k-1)%2+1),1
        add(inactive_player_settings,v)
    end
       
    add_player(0)
   
    camera_distance,camera_angle,camera_pos,next_game_state = 120,0,new_vector3d(0,-8,0),1
    mx,my = matrix_rotate_x(-0.1),matrix_rotate_y(camera_angle)
end

function update_game_settings()
    local ready_count,active_count = 0,#active_player_settings
    for k,v in pairs(active_player_settings) do
        update_menu(v.menu,v.controller)
       
        -- count the number of ready players
        if v.ready then
            ready_count += 1
        end
    end
   
    -- check unassaigned controllers for new players (unless a player has left this frame)
    if #active_player_settings == active_count and active_count < player_count and #inactive_player_settings >= 1 then
        for k,v in pairs(inactive_controllers) do
            if btnp(4,v) then
                add_player(v)
            end
        end
    end
   
    if #active_player_settings == 0 then
        init_main_menu()
        return
    elseif ready_count == #active_player_settings then
        new_game()
        return
    end
   
    -- rotate player models
    for k,v in pairs(player_settings) do
        v.player.angle += 0.0125
        if v.player.angle > 1 then
            v.player.angle -= 1
        end
        update_player(v.player)
    end
end

function add_player(controller)
    inactive_player_settings[1].controller = controller
    del(inactive_player_settings,add(active_player_settings,inactive_player_settings[1]))
    if controller then
        del(inactive_controllers,controller)
    end
end

function remove_player(player)
    if player.controller then
        add(inactive_controllers,player.controller)
    end
    player.controller,player.ready,player.menu.selected_index = nil,false,1
    local insert_index = 0
    for j=1,#inactive_player_settings do
        insert_index = j
        if inactive_player_settings[j].index > player.index then
            break
        end
    end
    table_insert(inactive_player_settings,player,insert_index)
    del(active_player_settings,player)
end

function ready_player(p)
    p.ready = true
end

function draw_color_range(x,y,selected,r)
    rectfill(x,y,x+#r*4,y+4,0)
    rect(x+(selected-1)*4,y,x+(selected-1)*4+4,y+4,7)
    x += 1
    y += 1
    for i=1,#r do
        rectfill(x,y,x+2,y+2,r[i][1])
        if r[i][2] then
            rectfill(x,y,x+2,y+1,r[i][2])
        end
        x += 4
    end
end

function draw_player_settings(x,y,player_setting,index)
    rectfill(x+6,y+25,x+58,y+31,0)
    if player_setting.controller == nil then
        print("cpu "..index,x+9,y+26,7)
        rectfill(x+6,y+32,x+58,y+61,5)
        print("press",x+22,y+38,6)
        print("button",x+20,y+44,6)
        print("to join",x+18,y+50,6)
    else
        print("player "..index,x+9,y+26,7)
        if player_setting.ready then
            rectfill(x+6,y+32,x+58,y+61,2)
            print("ready",x+22,y+44,7)
        else
            draw_menu(player_setting.menu,x+8,y+34)
        end
    end
    camera(-x+32,-y+36)
    player_setting.player:draw()
    camera()
end

function draw_game_settings()
    cls(3)
    local x,y = 0,0
    if player_count < 3 then
        y = 32
    end
    for i=1,player_count do
        draw_player_settings(x,y,player_settings[i],i)
        x += 63
        if x > 64 then
            x = 0
            y += 64
        end
    end
end
-->8
-- game & ball
function new_game(is_demo)
    if is_demo then
        camera_distance,camera_pos,camera_angle_x,no_control_timer,ai_dumbness = 160,new_vector3d(0,8,0),-0.065,1,10
    else
        camera_distance,camera_pos,camera_angle_x,no_control_timer,ai_dumbness = 120,new_vector3d(0,-5,0),-0.1,240,(5-settings[4])*10
        menuitem(1,"end match",end_match)
    end
   
    if (pos_data_cycled) cycle_pos_data()
   
    set_score_min,total_sets,camera_angle,camera_lerp_angles,camera_lerp_amount,score_text,court_bounds,game_score,set_score,set_scores,match_score,players,receiver_data,team_size,serving_team,serving_team_member = settings[2]*3,total_sets_list[settings[3]],0,{-0.25,0},0,{"0","15","30","40","adv"},{new_vector3d(-46,0,-64),new_vector3d(46,0,64)},{0,0},{0,0},{{0,0}},{{0,0}},{},player_count == 2 and singles_data or doubles_data,player_count/2,2,1

    for i=#active_player_settings+1,player_count do
        add_player()
    end
   
    local team_index,team_member_index,player_num,cpu_num = 1,1,1,1
   
    for k,v in pairs(active_player_settings) do
        local player = v.player
        player.court_side,player.team,player.team_member_index = team_index,team_index,team_member_index
        if v.controller then
            player.input,player.name = player_input_keyboard,"player "..player_num
            player_num += 1
        else
            player.input,player.name = player_input_ai,"cpu "..cpu_num
            cpu_num += 1
        end
        player.controller,player.mode,player.move_to,player.teammate,player.power = v.controller,2,{},nil,0
        player.pos_data = team_index==serving_team and server_data[team_index][team_member_index] or receiver_data[team_index][team_member_index]
        player.pos,player.angle = player.pos_data.start_pos,player.pos_data.start_angle
       
        add(players,v.player)
       
        team_member_index += 1
        if team_member_index > team_size then
            team_index += 1
            team_member_index = 1
        end
    end

    if team_size == 2 then
        players[1].teammate,players[2].teammate,players[3].teammate,players[4].teammate = players[2],players[1],players[4],players[3]
    end
   
    rotate_camera,service,change_sides,serve_num,message_func,timer_expired_func,next_game_state,ai_think_next_frame,ai_think = player_num == 0 or player_num-1 <= player_count / 2,players[(serving_team-1)*team_size+serving_team_member],true,0,nil,continue_match,is_demo and 0 or 2,false,false
   
    new_ball(0,-100,0)
    ball.vel.z = -service.facing*0.0001
    if not is_demo then
        music(-1,1000)
        musicplaying=false
    end
end

function continue_match()
    service.mode,ball.service,message_func = 0,true,nil
end

function return_to_mainmenu()
    menuitem(1)
    init_player_pool()
    init_main_menu()
end

function start_new_game()
    init_player_pool()
    new_game(true)
    update_game()
end

function update_game()
    if game_state ~= 2 then
        camera_angle = (camera_angle+0.0025)%1
    elseif camera_lerp_amount < 1 then
        camera_lerp_amount = min(camera_lerp_amount+0.005,1)
        camera_angle = smooth_lerp(camera_lerp_angles[1],camera_lerp_angles[2],camera_lerp_amount)
    end
   
    ai_think,ai_think_next_frame,mx,my = ai_think_next_frame,false,matrix_rotate_x(camera_angle_x),matrix_rotate_y(camera_angle)
   
    for poly_i,poly in pairs(polys) do
        for i,p in pairs(poly.points_3d) do
            poly.points_scr[i] = translate_to_view(p)
        end
    end
   
    translate_lines(court_lines,lines_scr)
    translate_lines(net,net_scr)
   
    z_sorted_objects = { net_scr }
   
    for k,v in pairs(players) do
        update_player(v)
        table_insert(z_sorted_objects,v,get_sort_index(v))
    end
   
    update_ball()
    table_insert(z_sorted_objects,ball,get_sort_index(ball_shadow))
   
    if no_control_timer > 0 then
        no_control_timer -= 1
        if no_control_timer <= 0 then
            for k,v in pairs(players) do
                v.mode = 1
            end
            timer_expired_func()
        end
    end
end

function translate_lines(line_table,scr_table)
    for k,v in pairs(line_table) do
        scr_table[k] = {
            translate_to_view(v[1]),
            translate_to_view(v[2]),
            v[3]
        }
    end
end

function draw_game()
    for k,v in pairs(polys) do
        draw_polygon(v)
    end
   
    draw_lines(lines_scr)
   
    for k,p in pairs(players) do
        if p.shadow_pos_scr then
            local sprite = p.sprite_model[7].sprites.sprites[1]
            draw_shadow(sprite[1],sprite[2],p.sprite_model[7].sprites.width,p.sprite_model[7].sprites.height,p.shadow_pos_scr.x+sprite[3],p.shadow_pos_scr.y+sprite[4])
        end
    end
   
    draw_shadow(8,56,5,4,ball_shadow.pos_scr.x-2,ball_shadow.pos_scr.y-1)
   
    for i=1,#z_sorted_objects do
        z_sorted_objects[i]:draw()
    end

    if game_state == 2 then
        for k,v in pairs(players) do
            local x,power_x,power_y,y,score_y = 0,2,7,1,0
            if v.pos_data.start_pos.x*v.move_dir > 0 then
                x,power_x = 125-#v.name*4, 110
            end
            if v.camera_side > 0 then
                score_y,y,power_y = 122,122,117
            end
            local right = x+(#v.name*4)
            palt(0,false)
            palt(2,true)
            sspr(0,12+v.power*16,16,4,power_x,power_y)
            sspr(game_score[v.team]*13,104,15,6,57,score_y)
            palt()
            rectfill(x,y-2,right+2,y+6,0)
            rectfill(x-1,y-1,right+3,y+5,0)
            print(v.name,x+2,y,color_sets[1][v.colors[1]][2])
        end

        if (message_func) message_func()
    end
end

function draw_big_text(text,x,y)
    local text_data,width = {},1
    for i=1,#text do
        text_data[i] = chars[sub(text,i,i)]
        width += text_data[i][3]-1
    end
    x -= width/2
    for i=1,#text_data do
        local td = text_data[i]
        sspr(td[1],td[2],td[3],td[4],x,y)
        x += td[3]-1
    end
end

function draw_big_messages(y)
    if message_text then
        draw_big_text(message_text,63,y)
        y -= 13
    end
    if message_reason then
        pal(1,2)
        pal(5,8)
        pal(12,9)
        pal(6,10)
        draw_big_text(message_reason,63,y)
        pal()
    end
end

function get_game_score_text()
    local score1,score2 = game_score[service.team]+1,game_score[service.team%2+1]+1
    if score1 == 4 and score1 == score2 then
        return "deuce"
    elseif score1 > 4 then
        return "adv in"
    elseif score2 > 4 then
        return "adv out"
    else
        return (score_text[score1].." - "..score_text[score2])
    end
end

function draw_message()
    draw_big_messages(43)
    if message_show_score then
        local score_text = get_game_score_text()
        local half_width = (#score_text*4)/2
        rectfill(58-half_width,56,66+half_width,64,7)
        print(score_text,63-half_width,58,0)
    end
end

function draw_set_score()
    draw_big_messages(32)
    draw_score_board(set_scores,"set")
end

function draw_match_score()
    draw_big_messages(32)
    draw_score_board(match_score,"match")
end

function get_team_name(team_num)
    local team_names = {players[1].name,players[2].name}
    if player_count == 4 then
        team_names[1],team_names[2] = get_short_name(team_names[1])..","..get_short_name(team_names[2]),get_short_name(players[3].name)..","..get_short_name(players[4].name)
    end
    return team_names[team_num]
end

function get_short_name(str)
    return sub(str,1,1)..sub(str,#str,#str)
end

function draw_score_board(scores,title)
    local team1name,team2name = get_team_name(1),get_team_name(2)
    if #scores > 8 and player_count == 2 then
        team1name,team2name = get_short_name(team1name),get_short_name(team2name)
    end
    local namelen = max(#team1name,#team2name)*4
    local x = 63-(namelen+#scores*8)/2
    local right = x+namelen+#scores*8+1
    rectfill(x+namelen+4,54,right,72,7)
    rectfill(right-6,54,right,72,12)
    rectfill(x+namelen+4,63,right-7,63,6)
    for i=1,#scores do
        local x2,txtcol = x+namelen+i*8-2,0
        if i == #scores then
            txtcol = 7
            x2 -= 1
        else
            rectfill(x2-3,54,x2-3,72,6)
        end
        print(scores[i][1],x2,56,txtcol)
        print(scores[i][2],x2,66,txtcol)
    end
    rectfill(x,45,right,53,0)
    print(title,x+2,47,7)
    rectfill(x,54,x+namelen+3,72,12)
    print(team1name,x+2,56,7)
    print(team2name,x+2,66,7)
end

function update_game_score(team,text)
    if no_control_timer <= 0 then
        message_reason,message_text,message_show_score,no_control_timer = text,nil,true,120
        local other_team = team%2+1
        for v in all(players) do
            v.move_to = {}
            v.ai_no_hit = 0
        end
       
        if ball.bounce_count <= 1 then
            if serve_num == 1 then
                message_reason,message_func,service.pos_data,message_show_score = "fault",draw_message,server_data[service.court_side][service.team_member_index],false
                for k,v in pairs(players) do
                    v.angle,v.move_to,v.mode = v.pos_data.start_angle,{v.pos_data.start_pos},2
                end
                return
            elseif serve_num == 2 then
                message_reason = "double fault"
            end
        end
       
        message_text,serve_num,message_func = get_team_name(team).." point",0,draw_message
       
        if game_score[team] == 3 then
            if game_score[other_team] == 4 then
                game_score[other_team] -= 1
            else
                game_score[team] += 1
               
                if game_score[other_team] ~= 3 then
                    end_game(team)
                end
            end
        elseif game_score[team] == 4 then
            game_score[team] += 1
            end_game(team)
        else
            game_score[team] += 1
        end
       
        -- players switch between left and right sides
        cycle_pos_data()

        -- move players for service
        for k,v in pairs(players) do
            v.power,v.pos_data,v.mode = 0,v.team==serving_team and server_data[v.court_side][v.team_member_index] or receiver_data[v.court_side][v.team_member_index],2
            v.angle = v.pos_data.start_angle
            add(v.move_to,v.pos_data.start_pos)
            if (v.team == serving_team and v.team_member_index == serving_team_member) service = v
        end

        ball.last_hit_player = nil
    end
end

function cycle_pos_data()
    for i=1,2 do
        for j=1,2 do
            local s,r = server_data[i][1],receiver_data[i][1]
            del(server_data[i],s)
            add(server_data[i],s)
            del(receiver_data[i],r)
            add(receiver_data[i],r)
        end
    end
    pos_data_cycled = not pos_data_cycled
end

function end_game(team)
    set_score[team] += 1
    set_scores[#set_scores],change_sides,message_func,no_control_timer = {0,0},(set_score[1]+set_score[2])%2==1,draw_set_score,240
    set_scores[#set_scores][team] = 1
    add(set_scores,{set_score[1],set_score[2]})
   
    if max(set_score[1],set_score[2]) >= set_score_min then
        local score_dif = set_score[1]-set_score[2]

        if score_dif >= 2 or set_score[1] == set_score_min+1 then
            -- team 1 victory
            end_set(1)
        elseif score_dif <= -2 or set_score[2] == set_score_min+1 then
            -- team 2 victory
            end_set(2)
        end
    end
   
    -- switch player service
    serving_team = serving_team%2+1
    if serving_team == 1 then
        for k,v in pairs(players) do
            v.team_member_index = v.team_member_index%team_size+1
        end
    end
   
    -- change sides after each odd numbered game
    if (set_score[1]+set_score[2])%2==1 then
        for k,v in pairs(players) do
            v.court_side = v.court_side%2+1
            -- move around the net
            if v.pos.z < 0 then
                v.move_to = {new_vector3d(40,0,-8),new_vector3d(40,0,8)}
            else
                v.move_to = {new_vector3d(-40,0,8),new_vector3d(-40,0,-8)}
            end
            if rotate_camera then
                camera_lerp_angles,camera_lerp_amount = camera_angle < 0.5 and {0,0.5} or {0.5,0},0
            end
        end
    end
   
    game_score = {0,0}
   
    if (not pos_data_cycled) cycle_pos_data()
end

function end_set(team)
    message_func,no_control_timer = draw_match_score,360
   
    local team_scores = match_score[#match_score]
    if set_score[1] > set_score[2] then
        team_scores[1] += 1
    else
        team_scores[2] += 1
    end
    match_score[#match_score] = {set_score[1],set_score[2]}

    add(match_score,team_scores)
   
    if #match_score==total_sets+1 or (total_sets==3 and max(team_scores[1],team_scores[2])==2) or (total_sets==5 and max(team_scores[1],team_scores[2])==3) then
        end_match(team_scores[1]>team_scores[2] and 1 or 2)
    end
    set_score,set_scores = {0,0},{{0,0}}
end

function end_match(team)
    if team then
        no_control_timer,message_text = 480,get_team_name(team).." wins"
    else
        no_control_timer = 1
    end
    if game_state ~= 2 then
        timer_expired_func = start_new_game
    else
        timer_expired_func,musicplaying = return_to_mainmenu,true
        music(0)
    end
end

-- ball
function new_ball(x,y,z)
    ball,ball_shadow,particles,particle_colors = {
        pos = new_vector3d(x,y,z),
        vel = new_vector3d(),
        bounce_pos = new_vector3d(),
        bounce_count = 0,
        service = true,
        draw = draw_ball,
        behind = behind_point
    },{
        pos = new_vector3d(x,0,z),
        draw = draw_ball_shadow,
        behind = behind_point
    },{},{{8,8,9,10},{8,9,10,7},{13,14,6,7},{12,12,6,7}}
end

function update_ball()
    if not ball.service then
        local scored = false
        ball.vel.y += 0.06
       
        -- hit net
        if ball.pos.y >= -6 
            and (ball.pos.z > 0) ~= (ball.pos.z + ball.vel.z > 0)
            and (ball.pos.x >= -32 and ball.pos.x <= 32) then
            ball.pos.z -= ball.vel.z
            ball.vel = new_vector3d()
            if ball.last_hit_player then
                update_game_score(ball.last_hit_player.team%2+1,"net")
            end
            scored,ball.on_fire = true,false
        end
       
        ball.pos = v3d_add(ball.pos,ball.vel)
       
        -- bounce
        if ball.pos.y > 0 then
            if (game_state ~= 0 and ball.vel.y > 0.23) sfx(1)
            ball.vel.y,ball.pos.y = -ball.vel.y*0.75,-ball.pos.y
            ball.bounce_count += 1
            if ball.last_hit_player then
                if not scored then
                    -- second bounce
                    if ball.bounce_count >= 2 then
                        update_game_score(ball.last_hit_player.team)
                        scored = true
                    -- bounce out of valid court area
                    elseif not point_in_rect(ball.pos,ball.valid_hit_region[1],ball.valid_hit_region[2]) then
                        update_game_score(ball.last_hit_player.team%2+1,"out")
                        scored = true
                    end
                end
            else
                -- failed to hit the ball on serve
                if service.mode == 3 then
                    ball.service,service.mode,ball.bounce_count = true,0,0
                end
            end
        end
        -- out of bounds on the full
        if not scored and not point_in_rect(ball.pos,court_bounds[1],court_bounds[2]) then
            if ball.last_hit_player then
                if ball.bounce_count == 1 then
                    ball.bounce_count += 1
                    update_game_score(ball.last_hit_player.team)
                else
                    update_game_score(ball.last_hit_player.team%2+1,"out")
                end
            end
            ball.vel.x,ball.vel.z,ball.on_fire = 0,0,false
        end
    else
        -- position to service player's hand (requires rotation the bone to the player's angle)
        ball.pos = v3d_add(service.pos,matrix_mul_add(matrix_rotate_x(0),matrix_mul_add(matrix_rotate_y(-service.angle),service.sprite_model[5].pos)))
    end
   
    ball_shadow.pos.x,ball_shadow.pos.z,ball.pos_scr = ball.pos.x,ball.pos.z,translate_to_view(ball.pos)
    ball_shadow.pos_scr = translate_to_view(ball_shadow.pos)
   
    for k,v in pairs(particles) do
        v.time -= 1
        if v.time <= 0 then
            del(particles,v)
        else
            table_insert(z_sorted_objects,v,get_sort_index(v))
        end
    end
   
    if ball.on_fire then
        local p_pos = v3d_sub(ball.pos,new_vector3d(0,2,0))
        for i=0,1 do
            local p,pi = add(particles,{pos_scr=translate_to_view(v3d_add(p_pos,v3d_mul_num(ball.vel,i/-2))),time = 20,col=ball.on_fire,draw=draw_particle,behind = behind_point}),get_sort_index(ball)
            table_insert(z_sorted_objects,p,pi)
        end
    end
end

function draw_particle(p)
    local size = (p.time/20)*1.85
    circfill(p.pos_scr.x,p.pos_scr.y,size,particle_colors[p.col][flr(p.time/20*(#particle_colors[p.col]-1))+1])
end

function calculate_bounce_point()
    local vel,pos = v3d_mul_num(ball.vel,1),v3d_mul_num(ball.pos,1)
    while pos.y < 0 do
        vel.y += 0.06
        pos = v3d_add(pos,vel)
    end
    pos.y = 0
    return pos
end

function draw_ball(b)
    sspr(0,56,5,5,b.pos_scr.x-2,b.pos_scr.y-4)
end
-->8
-- player
function new_player(x,z,angle,colors,input_function,team)
    return {
        pos = new_vector3d(x,0,z),
        angle = angle,
        vel = new_vector3d(),
        team = team,
        move_dir = 1,
        camera_side = 1,
        input = input_function,
        draw = draw_player,
        behind = behind_point,
        leg_anim = anims[1],
        leg_anim_time = 0,
        arm_anim = anims[6],
        arm_anim_time = 0,
        swing_timer = 0,
        power = 0,
        mode = 1,
        move_to = {},
        ai_hit_distance = 10,
        ai_delay = 0,
        ai_no_hit = 0,
        swing_dir = 1,
        ball_path_distance = 0,
        facing = z < 0 and 1 or -1,
        sprite_model = {
            new_sprite_container(sprites[2],0,-3,0,0),
            new_sprite_container(sprites[3],2.5,-4,-1.5,0.125),
            new_sprite_container(sprites[4],-1.25,0,0,0.125),
            new_sprite_container(sprites[4],1.25,0,0,-0.125),
            new_sprite_container(sprites[5],-2.5,-4,-1,0),
            new_sprite_container(sprites[6],2.5,-4,-1,0),
            new_sprite_container(sprites[1],0,2,0,0)
        },
        colors = colors
    }
end

function update_player(p)
    p.facing = p.pos.z < 0 and 1 or -1
    if p.input then
        if camera_angle < 0.25 or camera_angle > 0.75 then
            p.move_dir = 1
        else
            p.move_dir = -1
        end
        if (p.pos.z < 0) == (camera_angle < 0.25 or camera_angle > 0.75) then
            p.camera_side = -1
        else
            p.camera_side = 1
        end
       
        p.ball_path_distance = orient2d_xz(ball.pos,v3d_add(ball.pos,ball.vel),p.pos)
       
        if p.mode == 2 then
            if #p.move_to >= 1 then
                if player_move_to(p,p.move_to[1],2) then
                    del(p.move_to,p.move_to[1])
                    if #p.move_to == 0 then
                        p.angle = p.pos_data.start_angle
                    end
                else
                    local normal = v3d_normal(v3d_sub(p.move_to[1],p.pos))
                    p.angle = atan2(-normal.z,normal.x)
                end
            end
        else
            p:input()
        end   
       
        local new_pos = v3d_add(p.pos,p.vel)
       
        if p.mode ~= 2 then
            if p.vel.z < 0 and new_pos.z < p.pos_data.move_region[2] then
                new_pos.z,p.vel.z = p.pos_data.move_region[2],0
            end
            if p.vel.z > 0 and new_pos.z > p.pos_data.move_region[4] then
                new_pos.z,p.vel.z = p.pos_data.move_region[4],0
            end
            if p.vel.x < 0 and new_pos.x < p.pos_data.move_region[1] then
                new_pos.x,p.vel.x = p.pos_data.move_region[1],0
            end
            if p.vel.x > 0 and new_pos.x > p.pos_data.move_region[3] then
                new_pos.x,p.vel.x = p.pos_data.move_region[3],0
            end
        end
       
        -- set animations
        if v3d_length(p.vel) < 0.1 then
            -- not moving
            p.leg_anim = anims[1]
            if p.leg_anim_time > p.leg_anim[#p.leg_anim].to_time then
                p.leg_anim_time = 0
            end
        else
            -- if moving
            local move_angle = atan2(-p.vel.z,p.vel.x)-p.angle+0.125
            p.leg_anim = anims[flr((move_angle < 0 and move_angle+1 or (move_angle >= 1 and move_angle-1 or move_angle)*4))+2]
        end

        p.pos,p.vel = new_pos,v3d_mul_num(p.vel,0.8)
       
        if p.ball_path_distance > 0 or ball.vel.z == 0 or (ball.vel.z > 0) == (p.facing > 0) then
            p.swing_dir = 1
        else
            p.swing_dir = -1
        end

        if p.swing_timer <= 0 then
            if p.mode == 3 then
                if p.arm_anim ~= anims[10] then
                    p.arm_anim_time = 0
                end
                p.arm_anim = anims[10]
            elseif p.swing_dir >= 0 or p.mode == 0 or p.mode == 4 then
                if p.arm_anim ~= anims[6] then
                    p.arm_anim_time = 0
                end
                p.arm_anim = anims[6]
            else
                if p.arm_anim ~= anims[7] then
                    p.arm_anim_time = 0
                end
                p.arm_anim = anims[7]
            end
        end
       
        if p.swing_timer > 0 then
            -- hit the ball
            if p.swing_timer == 30 and (ball.vel.z == 0 or (ball.vel.z > 0) ~= (p.facing > 0)) then
                p.arm_anim_time = 0
                if p.arm_anim == anims[10] then
                    p.arm_anim = anims[11]
                elseif p.swing_dir < 0 then
                    p.arm_anim = anims[9]
                else
                    p.arm_anim = anims[8]
                end
                local ball_distance,hit_range = v3d_distance2d(p.pos,ball.pos),get_swing_dist(p.pos.z,p.move_dir)
                if ball_distance <= hit_range then
                    local power,direction,vert = 1.3+abs(p.pos.z/58)*0.7+(ball_distance/hit_range)*0.2, abs(ball.pos.x-p.pos.x)/(hit_range*2.5)*-p.swing_dir*p.move_dir*p.camera_side+(-ball.pos.x/64)*1.2,(ball.pos.y/18+lerp(0.9,1.0,abs(p.pos.z/58)*0.5+(ball_distance/hit_range*0.4)))*-1.25
                    ball.on_fire = false
                    if p.power_shot then
                        power += p.power*1.65
                        direction *= (p.power*0.7-1)*-1
                        ball.pos.y,vert,ball.on_fire,p.arm_anim = lerp(-16,-18,p.power),lerp(0.1,-0.15,abs(p.pos.z/58))+p.power*0.15,min(max(round(p.power*4),1),#particle_colors),anims[11]
                        if (game_state ~= 0) sfx(6)
                        p.power = -0.25
                    elseif p == service and serve_num > 0 then
                        vert = ball.pos.y/-18*0.5-0.7
                    end
                    if (game_state ~= 0) sfx(2+rnd(3))
                    ball.vel,ball.bounce_count,ball.last_hit_player,ball.valid_hit_region,ai_think_next_frame,p.power_shot,service.pos_data = v3d_mul_num(v3d_normal(new_vector3d(direction,vert,p.facing)),power),0,p,p.pos_data.valid_hit_region,true,false,receiver_data[service.court_side][service.team_member_index]
                    ball.bounce_pos = calculate_bounce_point()
                    if (p ~= service) serve_num = 0
                    if serve_num == 0 then
                        p.power = min(p.power+0.25,1)
                    end
                    for v in all(players) do
                        v.ai_no_hit = 0
                    end
                elseif game_state ~= 0 then
                    sfx(0)
                end
            end
            p.swing_timer -= 1
        end
       
        local new_leg_anim,new_arm_anim = nil,nil
        p.leg_anim_time,new_leg_anim = animate_limbs(p.sprite_model,p.leg_anim,p.leg_anim_time + 1)
        p.arm_anim_time,new_arm_anim = animate_limbs(p.sprite_model,p.arm_anim,p.arm_anim_time + 1)
       
        if new_leg_anim then
            p.leg_anim = new_leg_anim
        end
        if new_arm_anim then
            p.arm_anim = new_arm_anim
        end
    end
   
    -- prepare for rendering
    local m_player_rotation_x, m_player_rotation_y = matrix_rotate_x(0),matrix_rotate_y(-p.angle)
    p.pos_scr,p.sprite_model_sorted = translate_to_view(p.pos),{}
    for k,v in pairs(p.sprite_model) do
        v.pos_scr = translate_to_view(v3d_add(p.pos,matrix_mul_add(m_player_rotation_x,matrix_mul_add(m_player_rotation_y,v.pos))))
        v.pos_scr.x = round(v.pos_scr.x)
       
        if k == 7 then
            p.shadow_pos_scr = v.pos_scr
        else
            local insert_i = 0
            for i=1,#p.sprite_model_sorted do
                if v.pos_scr.z <= p.sprite_model_sorted[i].pos_scr.z then
                    insert_i = i
                    break
                end
            end
            table_insert(p.sprite_model_sorted,v,insert_i)
        end
    end
end

function get_swing_dist(z,cam_dir)
    return 13+(z/120*-cam_dir)*6
end

function player_input_keyboard(p)
    local move_speed = 0.175 * p.move_dir
    if btn(0,p.controller) then
        p.vel.x -= move_speed
    end
    if btn(1,p.controller) then
        p.vel.x += move_speed
    end
    if btn(2,p.controller) then
        p.vel.z -= move_speed
    end
    if btn(3,p.controller) then
        p.vel.z += move_speed
    end
    if btn(4,p.controller) then
        if not p.is_swing_pressed then
            p.power_shot = false
            p.is_swing_pressed = true
            if p.mode == 0 then
                serve(p)
                p.mode = 3
            elseif p.mode == 3 then
                p.swing_timer,p.mode = 30,1
                serve_num += 1
            elseif p.swing_timer <= 0 then
                p.swing_timer = 30
            end
        end
    elseif btn(5,p.controller) then
        if not p.is_swing_pressed and p.power > 0 then
            p.is_swing_pressed,p.swing_timer,p.power_shot = true,30,true
        end
    else
        p.is_swing_pressed = false
    end
end

function player_input_ai(p)
    if (ai_think) p.ai_delay = 0
    if p.ai_delay > 0 then
        p.ai_delay -= 1
        return
    end
    p.ai_no_hit = max(0,p.ai_no_hit-1)
    -- service mode
    if p.mode == 0 then
        p.move_to,p.mode = {new_vector3d(p.pos_data.move_region[1]+rnd(p.pos_data.move_region[3]-p.pos_data.move_region[1]),0,p.pos_data.move_region[2]+rnd(p.pos_data.move_region[4]-p.pos_data.move_region[2]))},4
    -- service mode 2
    elseif p.mode == 4 then
        if player_move_to(p,p.move_to[1],2) then
            p.move_to,p.ai_delay,p.mode = {},16+rnd(20),3
            serve(p)
        end
    -- service mode 3
    elseif p.mode == 3 then
        p.swing_timer,p.mode,p.power_shot = 30,1,false
        serve_num += 1
    elseif p.mode == 1 then
        if ai_think then
            if ball.last_hit_player and ball.last_hit_player.team ~= p.team
                and (not p.teammate or abs(p.ball_path_distance) <= abs(p.teammate.ball_path_distance)) then
                local back_dist = rnd(16)
                local dest = new_vector3d(ball.bounce_pos.x+ball.vel.x*back_dist+rnd(ai_dumbness)-ai_dumbness/2,0,ball.bounce_pos.z+ball.vel.z*back_dist+rnd(ai_dumbness)-ai_dumbness/2)
                local swing_dist = get_swing_dist(dest.z,p.move_dir)
                if ball.valid_hit_region and not point_in_rect(ball.bounce_pos,ball.valid_hit_region[1],ball.valid_hit_region[2]) then
                    dest = v3d_add(p.pos,v3d_mul_num(v3d_sub(dest,p.pos),0.5+rnd(0.5)))
                end
                p.move_to,p.ai_hit_distance,p.ai_delay = {dest},swing_dist*0.5+rnd(swing_dist*0.5)+rnd(ai_dumbness)*0.25,rnd(ai_dumbness*1.5)
            end
        end
   
        if (ball.vel.z > 0) ~= (p.facing > 0) then
            if #p.move_to >= 1 then
                if player_move_to(p,p.move_to[1],1) then
                    del(p.move_to,p.move_to[1])
                end
            end
           
            if p.swing_timer <= 0
                and p.ai_no_hit == 0
                and v3d_distance2d(p.pos,ball.pos) <= p.ai_hit_distance
                and    (ball.valid_hit_region == nil or point_in_rect(ball.bounce_pos,ball.valid_hit_region[1],ball.valid_hit_region[2]))then
                p.swing_timer = 30
                p.ai_no_hit = 90
                if p.power > 0 and rnd(1)<=rnd(p.power) and rnd(ai_dumbness)<8 then
                    p.power_shot = true
                end
            end
        end
    end
end

function serve(p)
    new_ball(p.pos.x,-3,p.pos.z + p.facing*6)
    ball.vel.y,ball.vel.z,ball.service,p.is_swing_pressed,p.swing_timer = -1.1,-p.facing*0.01,false,true,0
    if (game_state ~= 0) sfx(5)
end

function player_move_to(p,destination,nearness)
    local dist = v3d_distance2d(p.pos,destination) - nearness
    if dist > 0.001 then
        local normal = v3d_normal(v3d_sub(destination,p.pos))
        p.vel = v3d_add(p.vel,v3d_mul_num(normal,0.175))
        if dist < v3d_length(p.vel) then
            p.vel = v3d_mul_num(normal,dist)
        end
        return false
    end
    return true
end

function new_sprite_container(sprite_set,x,y,z,angle)
    return {
        sprites = sprite_set,
        pos = new_vector3d(x,y,z),
        angle = angle,
        pos_prev = new_vector3d(x,y,z),
        angle_prev = angle
    }
end

function animate_limbs(sprite_model,anim,new_time)
    local prev_frame,prev_frame_time = nil,0
   
    if new_time >= anim[#anim].to_time then
        if anim.loop then
            new_time,prev_frame = new_time%anim[#anim].to_time,anim[#anim]
        else
            set_pose(sprite_model,anim[#anim],anim[#anim],1)
            return 0,anim.on_finish ~= 0 and anims[anim.on_finish] or nil
        end
    end
    for i=1,#anim do
        if new_time < anim[i].to_time
            and new_time >= prev_frame_time then
                set_pose(sprite_model,prev_frame,anim[i],(new_time-prev_frame_time)/(anim[i].to_time-prev_frame_time))
            break
        end
        prev_frame,prev_frame_time = anim[i],anim[i].to_time
    end
       
    return new_time
end

function set_pose(sprite_model,prev_frame,next_frame,t)
    if prev_frame then
        for i=1,#prev_frame do
            local limb = sprite_model[prev_frame[i][1]]
            limb.pos_prev,limb.angle_prev,limb.sprites = prev_frame[i][2],prev_frame[i][3],sprites[prev_frame[i][4]]
        end
    end
   
    for i=1,#next_frame do
        local limb = sprite_model[next_frame[i][1]]
        limb.pos,limb.angle = v3d_lerp(limb.pos_prev,next_frame[i][2],t),lerp(limb.angle_prev,next_frame[i][3],t)
        if t >= 0.5 then
            limb.sprites = sprites[next_frame[i][4]]
        end
    end
end

function draw_shadow(spx,spy,spw,sph,x1,y1)
    local x2,y2 = min(x1+spw,128),min(y1+sph,128)
    if not (x2 < 0 or x1 > 127 or y2 < 0 or y1 > 127) then
        local x1min,y1min = max(x1,0),max(y1,0)
        local draw_width,draw_height = x2-x1min,y2-y1min
        copy_to_spritesheet(x1min,y1min,y2,draw_width,0)
        palt(0,false)
        palt(1,true)
        sspr(spx,spy,spw,sph,x1,y1,spw,sph)
        palt()
        copy_to_spritesheet(x1min,y1min,y2,draw_width,14)
        sspr(x1min%2,0,draw_width,draw_height,x1min,y1min,draw_width,draw_height)
        pal(3,1)
        pal(6,5)
        pal(13,1)
        sspr(14+x1min%2,0,draw_width,draw_height,x1min,y1min,draw_width,draw_height)
        pal()
    end
end

function copy_to_spritesheet(x1,y1,y2,width,offset)
    local dy = 0
    for i=y1,y2 do
        memcpy(dy*64+offset/2,0x6000+i*64+x1/2,ceil(width/2)+1)
        dy += 1
    end
end

function draw_player(p)
    pal(2,color_sets[1][p.colors[1]][1])
    pal(8,color_sets[1][p.colors[1]][2])
    pal(15,color_sets[2][p.colors[2]][1])
    pal(5,color_sets[3][p.colors[3]][1])
    pal(4,color_sets[3][p.colors[3]][2])
    pal(12,color_sets[4][p.colors[4]][1])
   
    for k,v in pairs(p.sprite_model_sorted) do
        local sp_count = #v.sprites.sprites
        local sprite = v.sprites.sprites[(flr((-camera_angle+1.5+p.angle+v.angle)*sp_count+0.5)%sp_count)+1]
        sspr(sprite[1],sprite[2],v.sprites.width,v.sprites.height,v.pos_scr.x+sprite[3],v.pos_scr.y+sprite[4],v.sprites.width,v.sprites.height,sprite[5],false)
    end
    pal()
end

-->8
-- world

function init_world()
    parse_addr,parse_nibble_offset,sprites,anims,pos_data_cycled,polys = 0x2000,0,{},{},false,{new_polygon({-46,0,-64,46,0,-64,46,0,64,-46,0,64},3)}
    for i=1,8 do
        add(sprites,read_sprite_data())
    end
    for i=1,11 do
        add(anims,read_anim_data())
    end
    server_data,singles_data,doubles_data,court_lines,net,lines_scr,net_scr,chars_index,chars = read_court_data(),read_court_data(),read_court_data(),read_line_data(),read_line_data(),{ draw = draw_lines },{ draw = draw_lines, behind = behind_lines }," -0123456789abcdefghijklmnopqrstuvwxyz,",{}
   
    local char_data,char_count = {},read_char()
    for i=1,char_count do
        char_data[i] = {}
        for j=1,4 do
            char_data[i][j] = read_char()
        end
        chars[sub(chars_index,i,i)] = char_data[i]
    end
end

function read_sprite_data()
    local s,sprite_count = {
        width = read_nibble(),
        height = read_nibble(),
        sprites = {}
    }, read_char()
   
    for i=1,sprite_count do
        add(s.sprites,{read_char(),read_char(),read_float8(),read_float8(),read_bool()})
    end
   
    return s
end

function read_anim_data()
    local anim,frame_count = { loop = read_bool(), on_finish = read_nibble() }, read_nibble()
    for f=1,frame_count do
        local frame,limb_count = { to_time = read_nibble() },read_nibble()
        for l=1,limb_count do
            add(frame,{read_nibble(),new_vector3d(read_float8(),read_float8(),read_float8()),read_float8(),read_nibble()})
        end
        add(anim,frame)
    end
    return anim
end

function read_line_data(l)
    local count,result = read_char(),{}
    for i=1,count do
        result[i] = {read_v3dchar_div2(),read_v3dchar_div2(),read_nibble()}
    end
    return result
end

function read_court_data()
    local d = {}
    for i=1,2 do
        local s = {}
        for j=1,4 do
            s[j] = {
                start_pos = read_v3dchar(),
                start_angle = read_float8(),
                move_region = {read_char(),read_char(),read_char(),read_char()},
                valid_hit_region = {read_v3dchar(),read_v3dchar()}
            }
        end
        d[i] = s
    end
    return d
end

function draw_lines(l)
    for i=1,#l do
        local v = l[i]
        line(v[1].x,v[1].y,v[2].x,v[2].y,v[3])
    end
end

function new_polygon(points,col)
    local p = {
        points_scr = {},
        points_3d = {},
        col = col
    }
   
    local p_count = #points - #points%3
   
    for i=1,p_count,3 do
        add(p.points_3d,new_vector3d(points[i],points[i+1],points[i+2]))
    end

    return p
end

function draw_polygon(poly)
    local points,xl,xr,ymin,ymax = poly.points_scr,{},{},32761,-32761
   
    for k,v in pairs(points) do
        local v_next = points[k%#points+1]
        local ys,ye = poly_edge(v,v_next,xl,xr)
        ymin,ymax = min(ys,ymin),max(ye,ymax)
    end

    for y=ymin,ymax do
        rectfill(xl[y],y,xr[y],y,poly.col)
    end
end

function poly_edge(p1,p2,xl,xr)
    local x1,y1,x2,y2,x_array = p1.x,flr(p1.y),p2.x,flr(p2.y),xr
   
    if y1 > y2 then
        x_array,y1,y2,x1,x2 = xl,y2,y1,x2,x1
    elseif y1 == y2 then
        if y1 < 0 then
            return 0,0
        elseif y1 > 127 then
            return 127,127
        end
        local xmin,xmax = flr(max(min(x1,x2),0)),flr(min(max(x1,x2),127))
        xl[y1],xr[y1] = not xl[y1] and xmin or min(xl[y1],xmin),not xr[y1] and xmax or max(xr[y1],xmax)
        return y1,y1
    end
   
    local ys,ye,xv,yv = max(y1,0),min(y2,127),x2-x1,y2-y1
    for y=ys,ye do
        x_array[y] = flr(x1+xv*(y-y1)/yv)
    end
    return ys,ye
end

-->8
-- vector & matrix
function new_vector3d(x,y,z)
    return {
        x = x and x or 0,
        y = y and y or 0,
        z = z and z or 0
    }
end

function v3d_add(a,b)
    return new_vector3d(a.x+b.x,a.y+b.y,a.z+b.z)
end

function v3d_sub(a,b)
    return new_vector3d(a.x-b.x,a.y-b.y,a.z-b.z)
end

function v3d_mul(a,b)
    return new_vector3d(a.x*b.x,a.y*b.y,a.z*b.z)
end

function v3d_mul_num(a,b)
    return new_vector3d(a.x*b,a.y*b,a.z*b)
end

function v3d_dot(a,b)
    local d = v3d_mul(a,b)
    return d.x+d.y+d.z
end

function v3d_cross(a,b)
    return new_vector3d(a.y*b.z-a.z*b.y,-(a.x*b.z-a.z*b.x),a.x*b.y-a.y*b.x)
end

function v3d_normal(self)
    local l = sqrt(v3d_dot(self,self))
    if l == 0 then
        return new_vector3d()
    end
    return new_vector3d(self.x/l,self.y/l,self.z/l)
end

function v3d_lerp(a,b,t)
    return new_vector3d(lerp(a.x,b.x,t),lerp(a.y,b.y,t),lerp(a.z,b.z,t))
end

function v3d_length(a)
    local d = v3d_dot(a,a)

    if d >= 0 then
        return sqrt(d)
    end
   
    return 32761
end

-- function v3d_distance(a,b)
    -- return v3d_length(v3d_sub(a,b))
-- end

function v3d_distance2d(a,b)
    return v3d_length(new_vector3d(a.x-b.x,0,a.z-b.z))
end

function orient2d_xy(a,b,c)
    return (a.x-c.x) * (b.y-c.y) - (a.y-c.y) * (b.x-c.x)
end

function orient2d_xz(a,b,c)
    return (a.x-c.x) * (b.z-c.z) - (a.z-c.z) * (b.x-c.x)
end

function matrix_rotate_x(a)
    return {{1,0,0},{0,sin(a),cos(a)},{0,cos(a),-sin(a)}}
end

function matrix_rotate_y(a)
    return {{cos(a),0,sin(a)},{-sin(a),0,cos(a)},{0,1,0}}
end

-- function matrix_rotate_z(a)
    -- return {{cos(a),-sin(a),0},{0,0,1},{sin(a),cos(0),0}}
-- end

function matrix_mul_add_row(m_row,v)
    return m_row[1]*v.x+m_row[2]*v.y+m_row[3]*v.z
end

function matrix_mul_add(m,v)
    return new_vector3d(matrix_mul_add_row(m[1],v),matrix_mul_add_row(m[2],v),matrix_mul_add_row(m[3],v))
end

function translate_to_view(v)
    local t = matrix_mul_add(mx,matrix_mul_add(my,v3d_add(camera_pos,v)))
    t.z += 192 -- camera fov
    return new_vector3d(round(t.z/camera_distance*t.x+64),round(t.z/camera_distance*t.y+64),t.z)
end
-->8
-- helpers

function table_insert(t,item,index)
    if index < 1 or index > #t then
        add(t,item)
    else
        for i=#t,index,-1 do
            t[i+1] = t[i]
        end
        t[index] = item
    end
end

function get_sort_index(o)
    for i=1,#z_sorted_objects do
        if z_sorted_objects[i]:behind(o) then
            return i
        end
    end
    return 0
end

function behind_point(p1,p2)
    return p2.pos_scr.z <= p1.pos_scr.z
end

function behind_lines(l,p)
    if l[1][1].x < l[1][2].x then
        return orient2d_xy(l[1][1],l[1][2],p.pos_scr) < 0
    end
    return orient2d_xy(l[1][1],l[1][2],p.pos_scr) > 0
end

function lerp(a,b,t)
    return a+(b-a)*t
end

function smooth_lerp(a,b,t)
    return lerp(a,b,t*t*(3-2*t))
end

function point_in_rect(p,r_min,r_max)
    return not (p.x < r_min.x or p.x > r_max.x or p.z < r_min.z or p.z > r_max.z)
end

function round(a)
    return a < 0 and ceil(a-0.5) or flr(a+0.5)
end

function read_float8()
    return read_char()/16
end

function read_char()
    local val = bor(shl(read_nibble(),4),read_nibble())
    if val >= 0x80 then
        val -= 256
    end
    return val
end

function read_v3dchar()
    return new_vector3d(read_char(),read_char(),read_char())
end

function read_v3dchar_div2()
    return new_vector3d(read_char()/2,read_char()/2,read_char()/2)
end

function read_bool()
    return read_nibble() ~= 0
end

function read_nibble()
    local val = peek(parse_addr+flr(parse_nibble_offset/2))
    if parse_nibble_offset%2 == 1 then
        val = band(val,0x0f)
    else
        val = shr(band(val,0xf0),4)
    end
    parse_nibble_offset += 1
    return val
end